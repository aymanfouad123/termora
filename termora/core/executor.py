"""
Command execution module for Termora.

This module handles the safe execution of command plans generated by the agent,
with user confirmation, backup creation, and output capture.
"""

import os
import subprocess
import tempfile
import tarfile
import shutil
import time
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any, Union
import sys

from rich.console import Console
from rich.prompt import Confirm
from rich.panel import Panel
from rich.syntax import Syntax

from termora.utils.helpers import get_termora_dir, get_timestamp, resolve_path, is_destructive_command

class CommandExecutor:
    """
    Executes command plans with safety measures.
    
    This class is responsible for executing commands from a command plan, ensuring user confirmation, creating backups of affected paths,
    and capturing command output.
    """
    
    def __init__(self, auto_confirm: bool = False, debug: bool = False):
        """
        Initialize the command executor.
        
        Args:
            auto_confirm: Whether to skip user confirmation
            debug: Whether to run in debug mode (print but don't execute)
        """
        self.auto_confirm = auto_confirm
        self.debug = debug
        self.console = Console()
        self.termora_dir = get_termora_dir()
        self.backup_dir = self.termora_dir / "backups"
        
        if not self.backup_dir.exists():
            self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # Last executed command info for rollback
        self.last_execution = None
    
    def display_plan(self, plan):
        """
        Display a command plan to the user.
        
        Args:
            plan: A CommandPlan instance
        """
        self.console.print("\n[bold green] Termora Plan:[/bold green]")
        
        # Display explanation
        self.console.print(Panel(
            plan.explanation,
            title="[bold]Explanation[/bold]",
            border_style="blue"
        ))
        
        # Display commands
        self.console.print("[bold]Commands to execute:[/bold]")
        for i, cmd in enumerate(plan.commands, 1):
            self.console.print(
                Panel(
                    Syntax(cmd, "bash", theme="monokai", line_numbers=False),
                    title=f"[bold]Command {i}[/bold]",
                    border_style="yellow" if is_destructive_command(cmd) else "green"
                )
            )
        
        # Display backup info if needed
        if plan.requires_backup:
            self.console.print("[bold yellow]⚠️ This operation requires backup for safety[/bold yellow]")
            if plan.backup_paths:
                self.console.print("The following paths will be backed up:")
                for path in plan.backup_paths:
                    self.console.print(f"  - {path}")
    
    def confirm_execution(self, plan) -> bool:
        """
        Ask for user confirmation before executing a plan.
        
        Args:
            plan: A CommandPlan instance
            
        Returns:
            Whether the user confirmed execution
        """
        
        if self.auto_confirm:
            self.console.print("[yellow]Auto-confirm enabled. Proceeding without confirmation.[/yellow]")
            return True
            
        if self.debug:
            self.console.print("[yellow]Debug mode enabled. Commands will not be executed.[/yellow]")
            return False
            
        return Confirm.ask("Run these commands?")

    def create_backup(self, paths: List[str]) -> str:
        """
        Create a backup of the specified paths.
        
        Args:
            paths: List of paths to back up
            
        Returns:
            Path to the created backup file
        """
        
        # Creating unique backup filename 
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"backup_{timestamp}.tar.gz"
        backup_path = self.backup_dir / backup_filename
        
        self.console.print(f"[blue]Creating backup at {backup_path}...[/blue]")
        
        # Create a temporary directory for backup
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            for path_str in paths:
                try:
                    # Resolve the path 
                    path = resolve_path(path_str)
                    
                    if not path.exists():
                        self.console.print(f"[yellow]Warning: Path does not exist, skipping: {path}[/yellow]")
                        continue
                    
                    # Create relative directory structure in temp directory
                    if path.is_absolute():
                        # For absolute paths, use the path structure starting from root
                        relative_path = str(path).lstrip('/')
                        dest_path = temp_path / relative_path
                    else:
                        # For relative paths, use as-is
                        dest_path = temp_path / path
                    
                    # Create parent directories
                    dest_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # Copy the file or directory 
                    if path.is_dir():
                        shutil.copytree(path, dest_path, symlinks=True)
                    else:
                        shutil.copy2(path, dest_path)
                    
                    self.console.print(f"[green]Backed up: {path}[/green]")
                    
                except Exception as e:
                    self.console.print(f"[red]Error backing up {path}: {str(e)}[/red]")
            with tarfile.open(backup_path, "w:gz") as tar:
                tar.add(temp_dir, arcname="")
        
        self.console.print(f"[green]Backup completed: {backup_path}[/green]")
        return str(backup_path)
                        