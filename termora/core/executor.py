"""
Command execution module for Termora.

This module handles the safe execution of command plans generated by the agent,
with user confirmation, backup creation, and output capture.

Overview - 
display_plan: Shows command plan to the user
confirm_execution: Asks user for confirmation
create_backup: Creates backup files
execute_plan: Runs the commands
_infer_backup_paths: Figures out what files to back up
"""

import os
import subprocess
import tempfile
import tarfile
import shutil
import re
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any, Union
import sys

from rich.console import Console
from rich.prompt import Confirm
from rich.panel import Panel
from rich.syntax import Syntax

from termora.utils.helpers import get_termora_dir, get_timestamp, resolve_path, is_destructive_command

class CommandExecutor:
    """
    Executes command plans with safety measures.
    
    This class is responsible for executing commands from a command plan, ensuring user confirmation, creating backups of affected paths,
    and capturing command output.
    """
    
    def __init__(self, auto_confirm: bool = False, debug: bool = False):
        """
        Initialize the command executor.
        
        Args:
            auto_confirm: Whether to skip user confirmation
            debug: Whether to run in debug mode (print but don't execute)
        """
        self.auto_confirm = auto_confirm
        self.debug = debug
        self.console = Console()
        self.termora_dir = get_termora_dir()
        self.backup_dir = self.termora_dir / "backups"
        
        if not self.backup_dir.exists():
            self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # Last executed command info for rollback
        self.last_execution = None
    
    def display_plan(self, plan):
        """
        Display a command plan to the user.
        
        Args:
            plan: A CommandPlan instance
        """
        self.console.print("\n[bold green] Termora Plan:[/bold green]")
        
        # Display explanation
        self.console.print(Panel(
            plan.explanation,
            title="[bold]Explanation[/bold]",
            border_style="blue"
        ))
        
        # Display commands
        self.console.print("[bold]Commands to execute:[/bold]")
        for i, cmd in enumerate(plan.commands, 1):
            self.console.print(
                Panel(
                    Syntax(cmd, "bash", theme="monokai", line_numbers=False),
                    title=f"[bold]Command {i}[/bold]",
                    border_style="yellow" if is_destructive_command(cmd) else "green"
                )
            )
        
        # Display backup info if needed
        if plan.requires_backup:
            self.console.print("[bold yellow]⚠️ This operation requires backup for safety[/bold yellow]")
            if plan.backup_paths:
                self.console.print("The following paths will be backed up:")
                for path in plan.backup_paths:
                    self.console.print(f"  - {path}")
    
    def confirm_execution(self, plan) -> bool:
        """
        Ask for user confirmation before executing a plan.
        
        Args:
            plan: A CommandPlan instance
            
        Returns:
            Whether the user confirmed execution
        """
        
        if self.auto_confirm:
            self.console.print("[yellow]Auto-confirm enabled. Proceeding without confirmation.[/yellow]")
            return True
            
        if self.debug:
            self.console.print("[yellow]Debug mode enabled. Commands will not be executed.[/yellow]")
            return False
            
        return Confirm.ask("Run these commands?")

    def create_backup(self, paths: List[str]) -> str:
        """
        Create a backup of the specified paths.
        
        Args:
            paths: List of paths to back up
            
        Returns:
            Path to the created backup file
        """
        
        # Creating unique backup filename 
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"backup_{timestamp}.tar.gz"
        backup_path = self.backup_dir / backup_filename
        
        self.console.print(f"[blue]Creating backup at {backup_path}...[/blue]")
        
        # Create a temporary directory for backup
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            for path_str in paths:
                try:
                    # Resolve the path - Expanding things like ~ to full paths
                    path = resolve_path(path_str)
                    
                    if not path.exists():
                        self.console.print(f"[yellow]Warning: Path does not exist, skipping: {path}[/yellow]")
                        continue
                    
                    # Create same directory structure in temp directory
                    if path.is_absolute():
                        # For absolute paths, use the path structure starting from root
                        relative_path = str(path).lstrip('/')
                        dest_path = temp_path / relative_path
                    else:
                        # For relative paths, use as-is
                        dest_path = temp_path / path
                    
                    # Create parent directories
                    dest_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # Copy the file or directory 
                    if path.is_dir():
                        shutil.copytree(path, dest_path, symlinks=True)
                    else:
                        shutil.copy2(path, dest_path)
                    
                    self.console.print(f"[green]Backed up: {path}[/green]")
                    
                except Exception as e:
                    self.console.print(f"[red]Error backing up {path}: {str(e)}[/red]")
            
            with tarfile.open(backup_path, "w:gz") as tar:
                tar.add(temp_dir, arcname="")
        
        self.console.print(f"[green]Backup completed: {backup_path}[/green]")
        return str(backup_path)
    
    def execute_plan(self, plan) -> Dict[str, Any]:
        """
        Execute a command plan.
        
        Args:
            plan: A CommandPlan instance
            
        Returns:
            Execution result with commands, outputs, and backup info
        """
        
        # Display the plan
        self.display_plan(plan)
        
        # Get confirmation
        if not self.confirm_execution(plan):
            self.console.print("[yellow]Execution cancelled by user.[/yellow]")
            return {
                "executed": False,
                "reason": "User cancelled",
                "commands": plan.commands,
                "outputs": [],
                "backup_path": None
            }
        
        # Create backup if needed
        backup_path = None
        if plan.requires_backup:
            # Determine what to back up
            backup_paths = plan.backup_paths
            if not backup_paths:
                # If no specific paths provided, infer from commands
                backup_paths = self._infer_backup_paths(plan.commands)
                
            if backup_paths:
                backup_path = self.create_backup(backup_paths)
        
        # Debug mode - don't actually execute
        if self.debug:
            self.console.print("[yellow]Debug mode: Commands not executed[/yellow]")
            return {
                "executed": False,
                "reason": "Debug mode",
                "commands": plan.commands,
                "outputs": ["Debug mode: Command not executed"] * len(plan.commands),
                "backup_path": backup_path
            }
        
         # Execute commands
        self.console.print("\n[bold blue] Executing commands...[/bold blue]")
        outputs = []
        
        for i, cmd in enumerate(plan.commands, 1):
            self.console.print(f"\n[bold]Running command {i}/{len(plan.commands)}:[/bold]")
            self.console.print(Syntax(cmd, "bash", theme="monokai"))
            
            try:
                # Execute the command
                process = subprocess.run(
                    cmd,
                    shell=True,
                    capture_output=True,
                    text=True
                )
                
                # Capture output
                if process.stdout:
                    self.console.print("[green]Output:[/green]")
                    self.console.print(process.stdout)
                
                # Capture errors
                if process.returncode != 0:
                    self.console.print("[bold red]Command failed with error:[/bold red]")
                    self.console.print(process.stderr)
                
                outputs.append({
                    "command": cmd,
                    "stdout": process.stdout,
                    "stderr": process.stderr,
                    "return_code": process.returncode,
                    "success": process.returncode == 0
                })
            
            except Exception as e:
                self.console.print(f"[bold red]Error executing command: {str(e)}[/bold red]")
                outputs.append({
                    "command": cmd,
                    "error": str(e),
                    "success": False
                })
            
        # Store execution info for potential rollback
        execution_info = {
            "executed": True,
            "commands": plan.commands,
            "outputs": outputs,
            "backup_path": backup_path,
            "timestamp": get_timestamp()
        }
        
        self.last_execution = execution_info
        
        # Final summary
        success_count = sum(1 for output in outputs if output.get("success", False))
        if success_count == len(plan.commands):
            self.console.print("\n[bold green] All commands executed successfully![/bold green]")
        else:
            self.console.print(f"\n[bold yellow]⚠️ {success_count}/{len(plan.commands)} commands succeeded[/bold yellow]")
            if backup_path:
                self.console.print(f"[blue]A backup was created at: {backup_path}[/blue]")
                self.console.print("[blue]You can restore it with 'termora rollback last'[/blue]")
        
        return execution_info
    
    def _infer_backup_paths(self, commands: List[str]) -> List[str]:
        """
        Infer paths that should be backed up based on commands.
        
        Args:
            commands: List of shell commands
            
        Returns:
            List of paths that should be backed up
        """
        backup_paths = set()
        
        # Patterns to look for in destructive commands
        patterns = [
            # rm/rmdir commands: extract paths after the command and options
            (r'rm\s+(?:-[rf]+\s+)*(.+)', 1),
            # mv commands: extract the source path (not the destination)
            (r'mv\s+(?:-[if]+\s+)*(.+?)\s+[^\s]+$', 1),
            # redirect operations: extract the file being written to
            (r'>\s*(.+)', 1),
            # sed -i: extract the file being modified
            (r'sed\s+-i.*\s+(.+)', 1),
        ]
        
        for cmd in commands:
            if is_destructive_command(cmd):
                for pattern, group in patterns:
                    match = re.search(pattern, cmd)
                    if match:
                        # Extract the path and split if multiple paths
                        paths = match.group(group).split()
                        for path in paths:
                            # Remove any quotes or trailing characters
                            clean_path = path.strip('\'"')
                            if clean_path:
                                backup_paths.add(clean_path)
        
        return list(backup_paths)