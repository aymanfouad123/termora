"""
Command execution module for Termora.

This module handles the safe execution of command plans generated by the agent,
with user confirmation, backup creation, and output capture.

Key functionality:
- CommandExecutor: Main class for executing commands safely
- execute_plan: Runs an ActionPlan with backup and confirmation
- display_plan: Shows commands to the user before execution
- create_backup: Creates backups of potentially affected files
- _execute_shell_command: Runs shell commands with output capture
- _execute_python_code: Runs Python code safely in a sandboxed environment

Arguments:
- auto_confirm: Skip confirmation prompts for all commands
- debug: Run in debug mode (don't actually execute commands)

Overview - 
display_plan: Shows command plan to the user
confirm_execution: Asks user for confirmation
create_backup: Creates backup files
execute_plan: Runs the commands
_infer_backup_paths: Figures out what files to back up
"""

import os
import subprocess
import tempfile
import tarfile
import shutil
import re
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any, Union
import sys

from rich.console import Console
from rich.prompt import Confirm
from rich.panel import Panel
from rich.syntax import Syntax

from termora.utils.helpers import get_termora_dir, get_timestamp, resolve_path, is_destructive_command

class CommandExecutor:
    """
    Executes command plans with safety measures.
    
    This class is responsible for executing commands from a command plan, ensuring user confirmation, creating backups of affected paths,
    and capturing command output.
    """
    
    def __init__(self, auto_confirm: bool = False, debug: bool = False):
        """
        Initialize the command executor.
        
        Args:
            auto_confirm: Whether to skip user confirmation
            debug: Whether to run in debug mode (print but don't execute)
        """
        self.auto_confirm = auto_confirm
        self.debug = debug
        self.console = Console()
        self.termora_dir = get_termora_dir()
        self.backup_dir = self.termora_dir / "backups"
        
        if not self.backup_dir.exists():
            self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # Last executed command info for rollback
        self.last_execution = None
    
    def display_plan(self, plan):
        """
        Display a command plan to the user.
        
        Args:
            plan: An ActionPlan instance
        """
        self.console.print("\n[bold green] Termora Plan:[/bold green]")
        
        # Display explanation
        self.console.print(Panel(
            plan.explanation,
            title="[bold]Explanation[/bold]",
            border_style="blue"
        ))
        
        # Display actions
        self.console.print("[bold]Actions to execute:[/bold]")
    
        for i, action in enumerate(plan.actions, 1):
            action_type = action.get("type", "shell_command")
            content = action.get("content", "")
            explanation = action.get("explanation", "")
            
            # Choose language for syntax highlighting
            language = "bash" if action_type == "shell_command" else "python"
            
            # Set color based on action type and content
            if action_type == "shell_command" and is_destructive_command(content):
                border_style = "yellow"
            elif action_type == "python_code":
                border_style = "purple"
            else:
                border_style = "green"
            
            title = f"[bold]{action_type.replace('_', ' ').title()} {i}[/bold]"     # Basic formatting 
            if explanation:
                title += f": {explanation}"
                
            self.console.print(
                Panel(
                    Syntax(content, language, theme="monokai", line_numbers=False),
                    title=title,
                    border_style=border_style
                )
            )
            
        # Display backup info if needed
        if plan.requires_backup:
            self.console.print("[bold yellow] This operation requires backup for safety[/bold yellow]")
            if plan.backup_paths:
                self.console.print("The following paths will be backed up:")
                for path in plan.backup_paths:
                    self.console.print(f"  - {path}")
    
    def confirm_execution(self, plan) -> bool:
        """
        Ask for user confirmation before executing a plan.
        
        Args:
            plan: An ActionPlan instance
            
        Returns:
            Whether the user confirmed execution
        """
        
        if self.auto_confirm:
            self.console.print("[yellow]Auto-confirm enabled. Proceeding without confirmation.[/yellow]")
            return True
            
        if self.debug:
            self.console.print("[yellow]Debug mode enabled. Actions will not be executed.[/yellow]")
            return False
            
        return Confirm.ask("Run these actions?")

    def create_backup(self, paths: List[str]) -> str:
        """
        Create a backup of the specified paths.
        
        Args:
            paths: List of paths to back up
            
        Returns:
            Path to the created backup file
        """
        
        # Creating unique backup filename 
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"backup_{timestamp}.tar.gz"
        backup_path = self.backup_dir / backup_filename
        
        self.console.print(f"[blue]Creating backup at {backup_path}...[/blue]")
        
        # Create a temporary directory for backup
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            for path_str in paths:
                try:
                    # Resolve the path - Expanding things like ~ to full paths
                    path = resolve_path(path_str)
                    
                    if not path.exists():
                        self.console.print(f"[yellow]Warning: Path does not exist, skipping: {path}[/yellow]")
                        continue
                    
                    # Create same directory structure in temp directory
                    if path.is_absolute():
                        # For absolute paths, use the path structure starting from root
                        relative_path = str(path).lstrip('/')
                        dest_path = temp_path / relative_path
                    else:
                        # For relative paths, use as-is
                        dest_path = temp_path / path
                    
                    # Create parent directories
                    dest_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # Copy the file or directory 
                    if path.is_dir():
                        shutil.copytree(path, dest_path, symlinks=True)
                    else:
                        shutil.copy2(path, dest_path)
                    
                    self.console.print(f"[green]Backed up: {path}[/green]")
                    
                except Exception as e:
                    self.console.print(f"[red]Error backing up {path}: {str(e)}[/red]")
            
            with tarfile.open(backup_path, "w:gz") as tar:
                tar.add(temp_dir, arcname="")
        
        self.console.print(f"[green]Backup completed: {backup_path}[/green]")
        return str(backup_path)
    
    def execute_plan(self, plan) -> Dict[str, Any]:
        """
        Execute an action plan.
        
        Args:
            plan: An ActionPlan instance
            
        Returns:
            Execution result with actions, outputs, and backup info
        """
        
        # Display the plan
        self.display_plan(plan)
        
        # Get confirmation
        if not self.confirm_execution(plan):
            self.console.print("[yellow]Execution cancelled by user.[/yellow]")
            return {
                "executed": False,
                "reason": "User cancelled",
                "commands": plan.commands,
                "outputs": [],
                "backup_path": None
            }
        
        # Create backup if needed
        backup_path = None
        if plan.requires_backup:
            # Determine what to back up
            backup_paths = plan.backup_paths
            if not backup_paths:
                # If no specific paths provided, infer from commands
                shell_commands = [action["content"] for action in plan.actions 
                             if action.get("type") == "shell_command"]
                backup_paths = self._infer_backup_paths(shell_commands)
            
            
            if backup_paths:
                backup_path = self.create_backup(backup_paths)
        
        # Debug mode - don't actually execute
        if self.debug:
            self.console.print("[yellow]Debug mode: Commands not executed[/yellow]")
            return {
                "executed": False,
                "reason": "Debug mode",
                "actions": plan.actions,
                "outputs": [],
                "backup_path": backup_path
            }
        
         # Execute commands
        self.console.print("\n[bold blue] Executing actions...[/bold blue]")
        outputs = []
        
        for i, action in enumerate(plan.actions, 1):
            action_type = action.get("type", "shell_command")
            content = action.get("content", "")
            
            self.console.print(f"\n[bold]Running {action_type.replace('_', ' ')} {i}/{len(plan.actions)}:[/bold]")
            language = "bash" if action_type == "shell_command" else "python"
            self.console.print(Syntax(content, language, theme="monokai"))
            
            try:
                if action_type == "shell_command":
                    # Execute shell command
                    output = self._execute_shell_command(content)
                elif action_type == "python_code":
                    # Execute Python code
                    output = self._execute_python_code(content)
                else:
                    raise ValueError(f"Unknown action type: {action_type}")
                
                outputs.append(output)
            except Exception as e:
                self.console.print(f"[bold red]Error executing {action_type}: {str(e)}[/bold red]")
                outputs.append({
                    "action": action,
                    "error": str(e),
                    "success": False
                })
            
        # Store execution info for potential rollback
        execution_info = {
            "executed": True,
            "actions": plan.actions,
            "outputs": outputs,
            "backup_path": backup_path,
            "timestamp": get_timestamp()
        }
        
        self.last_execution = execution_info
        
        # Final summary
        success_count = sum(1 for output in outputs if output.get("success", False))
        total_count = len(plan.actions)
        
        if success_count == total_count:
            self.console.print(f"\n[bold green] All {total_count} actions executed successfully![/bold green]")
        else:
            self.console.print(f"\n[bold yellow]⚠️ {success_count}/{total_count} actions succeeded[/bold yellow]")
            if backup_path:
                self.console.print(f"[blue]A backup was created at: {backup_path}[/blue]")
                self.console.print("[blue]You can restore it with 'termora rollback last'[/blue]")
        
        return execution_info
    
    def _infer_backup_paths(self, commands: List[str]) -> List[str]:
        """
        Infer paths that should be backed up based on commands.
        
        Args:
            commands: List of shell commands
            
        Returns:
            List of paths that should be backed up
        """
        backup_paths = set()
        
        # Patterns to look for in destructive commands
        patterns = [
            # rm/rmdir commands: extract paths after the command and options
            (r'rm\s+(?:-[rf]+\s+)*(.+)', 1),
            # mv commands: extract the source path (not the destination)
            (r'mv\s+(?:-[if]+\s+)*(.+?)\s+[^\s]+$', 1),
            # redirect operations: extract the file being written to
            (r'>\s*(.+)', 1),
            # sed -i: extract the file being modified
            (r'sed\s+.*\s+([^\s]+)$', 1),
        ]
        
        for cmd in commands:
            if is_destructive_command(cmd):
                for pattern, group in patterns:
                    match = re.search(pattern, cmd)
                    if match:
                        # Extract the path and split if multiple paths
                        paths = match.group(group).split()
                        for path in paths:
                            # Remove any quotes or trailing characters
                            clean_path = path.strip('\'"')
                            if clean_path:
                                backup_paths.add(clean_path)
        
        return list(backup_paths)