"""
Command execution module for Termora.

This module handles the safe execution of command plans generated by the agent,
with user confirmation, backup creation, and output capture.

Key functionality:
- CommandExecutor: Main class for executing commands safely
- execute_plan: Runs an ActionPlan with backup and confirmation
- display_plan: Shows commands to the user before execution
- create_backup: Creates backups of potentially affected files
- _execute_shell_command: Runs shell commands with output capture
- _execute_python_code: Runs Python code safely in a sandboxed environment

Arguments:
- auto_confirm: Skip confirmation prompts for all commands
- debug: Run in debug mode (don't actually execute commands)

Overview - 
display_plan: Shows command plan to the user
confirm_execution: Asks user for confirmation
create_backup: Creates backup files
execute_plan: Runs the commands
_infer_backup_paths: Figures out what files to back up
"""

import os
import subprocess
import tempfile
import tarfile
import shutil
import re
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any, Union
import sys
import time

from rich.console import Console
from rich.prompt import Confirm
from rich.panel import Panel
from rich.syntax import Syntax

from termora.utils.helpers import get_termora_dir, get_timestamp, resolve_path, is_destructive_command

class CommandExecutor:
    """
    Executes command plans with safety measures.
    
    This class is responsible for executing commands from a command plan, ensuring user confirmation, creating backups of affected paths,
    and capturing command output.
    """
    
    def __init__(self, auto_confirm: bool = False, debug: bool = False):
        """
        Initialize the command executor.
        
        Args:
            auto_confirm: Whether to skip user confirmation
            debug: Whether to run in debug mode (print but don't execute)
        """
        self.auto_confirm = auto_confirm
        self.debug = debug
        self.console = Console()
        self.termora_dir = get_termora_dir()
        self.backup_dir = self.termora_dir / "backups"
        
        if not self.backup_dir.exists():
            self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # Last executed command info for rollback
        self.last_execution = None
    
    def display_plan(self, plan):
        """
        Display a command plan to the user.
        
        Args:
            plan: An ActionPlan instance
        """
        self.console.print("\n[bold green] Termora Plan:[/bold green]")
        
        # Display explanation
        self.console.print(Panel(
            plan.explanation,
            title="[bold]Explanation[/bold]",
            border_style="blue"
        ))
        
        # Display actions
        self.console.print("[bold]Actions to execute:[/bold]")
    
        for i, action in enumerate(plan.actions, 1):
            action_type = action.get("type", "shell_command")
            content = action.get("content", "")
            explanation = action.get("explanation", "")
            
            # Choose language for syntax highlighting
            language = "bash" if action_type == "shell_command" else "python"
            
            # Set color based on action type and content
            if action_type == "shell_command" and is_destructive_command(content):
                border_style = "yellow"
            elif action_type == "python_code":
                border_style = "purple"
            else:
                border_style = "green"
            
            title = f"[bold]{action_type.replace('_', ' ').title()} {i}[/bold]"     # Basic formatting 
            if explanation:
                title += f": {explanation}"
                
            self.console.print(
                Panel(
                    Syntax(content, language, theme="monokai", line_numbers=False),
                    title=title,
                    border_style=border_style
                )
            )
            
        # Display backup info if needed
        if plan.requires_backup:
            self.console.print("[bold yellow] This operation requires backup for safety[/bold yellow]")
            if plan.backup_paths:
                self.console.print("The following paths will be backed up:")
                for path in plan.backup_paths:
                    self.console.print(f"  - {path}")
    
    def confirm_execution(self, plan) -> bool:
        """
        Ask for user confirmation before executing a plan.
        
        Args:
            plan: An ActionPlan instance
            
        Returns:
            Whether the user confirmed execution
        """
        
        if self.auto_confirm:
            self.console.print("[yellow]Auto-confirm enabled. Proceeding without confirmation.[/yellow]")
            return True
            
        if self.debug:
            self.console.print("[yellow]Debug mode enabled. Actions will not be executed.[/yellow]")
            return False
            
        return Confirm.ask("Run these actions?")

    def create_backup(self, paths: List[str]) -> str:
        """
        Create a backup of the specified paths.
        
        Args:
            paths: List of paths to back up
            
        Returns:
            Path to the created backup file
        """
        
        # Creating unique backup filename 
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"backup_{timestamp}.tar.gz"
        backup_path = self.backup_dir / backup_filename
        
        self.console.print(f"[blue]Creating backup at {backup_path}...[/blue]")
        
        # Create a temporary directory for backup
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            for path_str in paths:
                try:
                    # Resolve the path - Expanding things like ~ to full paths
                    path = resolve_path(path_str)
                    
                    if not path.exists():
                        self.console.print(f"[yellow]Warning: Path does not exist, skipping: {path}[/yellow]")
                        continue
                    
                    # Create same directory structure in temp directory
                    if path.is_absolute():
                        # For absolute paths, use the path structure starting from root
                        relative_path = str(path).lstrip('/')
                        dest_path = temp_path / relative_path
                    else:
                        # For relative paths, use as-is
                        dest_path = temp_path / path
                    
                    # Create parent directories
                    dest_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # Copy the file or directory 
                    if path.is_dir():
                        shutil.copytree(path, dest_path, symlinks=True)
                    else:
                        shutil.copy2(path, dest_path)
                    
                    self.console.print(f"[green]Backed up: {path}[/green]")
                    
                except Exception as e:
                    self.console.print(f"[red]Error backing up {path}: {str(e)}[/red]")
            
            with tarfile.open(backup_path, "w:gz") as tar:
                tar.add(temp_dir, arcname="")
        
        self.console.print(f"[green]Backup completed: {backup_path}[/green]")
        return str(backup_path)
    
    def execute_plan(self, plan) -> Dict[str, Any]:
        """
        Execute an action plan.
        
        Args:
            plan: An ActionPlan instance
            
        Returns:
            Execution result with actions, outputs, and backup info
        """
        
        # Display the plan
        self.display_plan(plan)
        
        # Get confirmation
        if not self.confirm_execution(plan):
            self.console.print("[yellow]Execution cancelled by user.[/yellow]")
            return {
                "executed": False,
                "reason": "User cancelled",
                "actions": plan.actions,
                "outputs": [],
                "backup_path": None
            }
        
        # Create backup if needed
        backup_path = None
        if plan.requires_backup:
            # Determine what to back up
            backup_paths = plan.backup_paths
            if not backup_paths:
                # If no specific paths provided, infer from commands
                shell_commands = [action["content"] for action in plan.actions 
                             if action.get("type") == "shell_command"]
                backup_paths = self._infer_backup_paths(shell_commands)
            
            
            if backup_paths:
                backup_path = self.create_backup(backup_paths)
        
        # Debug mode - don't actually execute
        if self.debug:
            self.console.print("[yellow]Debug mode: Commands not executed[/yellow]")
            return {
                "executed": False,
                "reason": "Debug mode",
                "actions": plan.actions,
                "outputs": [],
                "backup_path": backup_path
            }
        
         # Execute commands
        self.console.print("\n[bold blue] Executing actions...[/bold blue]")
        outputs = []
        success_count = 0
        
        for i, action in enumerate(plan.actions, 1):
            action_type = action.get("type", "shell_command")
            content = action.get("content", "")
            fallback = action.get("fallback", None)  # Get fallback command if available
            
            self.console.print(f"\n[bold]Running {action_type.replace('_', ' ')} {i}/{len(plan.actions)}:[/bold]")
            language = "bash" if action_type == "shell_command" else "python"
            self.console.print(Syntax(content, language, theme="monokai"))
            
            try:
                if action_type == "shell_command":
                    # Execute shell command with fallback if available
                    output = self._execute_shell_command(content, fallback)
                elif action_type == "python_code":
                    # Execute Python code
                    output = self._execute_python_code(content)
                else:
                    raise ValueError(f"Unknown action type: {action_type}")
                
                outputs.append(output)
                if output.get("success", False):
                    success_count += 1
            except Exception as e:
                self.console.print(f"[bold red]Error executing {action_type}: {str(e)}[/bold red]")
                outputs.append({
                    "action": action,
                    "error": str(e),
                    "success": False
                })
            
        # Store execution info for potential rollback
        execution_info = {
            "executed": True,
            "actions": plan.actions,
            "outputs": outputs,
            "backup_path": backup_path,
            "timestamp": get_timestamp()
        }
        
        self.last_execution = execution_info
        
        # Final summary
        total_count = len(plan.actions)
        
        if success_count == total_count:
            self.console.print(f"\n[bold green] All {total_count} actions executed successfully![/bold green]")
        else:
            self.console.print(f"\n[bold yellow]⚠️ {success_count}/{total_count} actions succeeded[/bold yellow]")
            if backup_path:
                self.console.print(f"[blue]A backup was created at: {backup_path}[/blue]")
                self.console.print("[blue]You can restore it with 'termora rollback last'[/blue]")
        
        # Only mark as executed if at least one command succeeded
        execution_info["executed"] = success_count > 0
        # Add a reason if none of the commands succeeded
        if success_count == 0:
            execution_info["reason"] = "All commands failed to execute"
        
        return execution_info
    
    def _infer_backup_paths(self, commands: List[str]) -> List[str]:
        """
        Infer paths that should be backed up based on commands.
        
        Args:
            commands: List of shell commands
            
        Returns:
            List of paths that should be backed up
        """
        backup_paths = set()
        
        # Patterns to look for in destructive commands
        patterns = [
            # rm/rmdir commands: extract paths after the command and options
            (r'rm\s+(?:-[rf]+\s+)*(.+)', 1),
            # mv commands: extract the source path (not the destination)
            (r'mv\s+(?:-[if]+\s+)*(.+?)\s+[^\s]+$', 1),
            # redirect operations: extract the file being written to
            (r'>\s*(.+)', 1),
            # sed -i: extract the file being modified
            (r'sed\s+.*\s+([^\s]+)$', 1),
        ]
        
        for cmd in commands:
            if is_destructive_command(cmd):
                for pattern, group in patterns:
                    match = re.search(pattern, cmd)
                    if match:
                        # Extract the path and split if multiple paths
                        paths = match.group(group).split()
                        for path in paths:
                            # Remove any quotes or trailing characters
                            clean_path = path.strip('\'"')
                            if clean_path:
                                backup_paths.add(clean_path)
        
        return list(backup_paths)

    def _execute_shell_command(self, command: str, fallback: str = None) -> Dict[str, Any]:
        """
        Execute a shell command and return the result.
        
        Args:
            command: The command to execute
            fallback: Optional fallback command to run if the primary fails
            
        Returns:
            Dictionary with execution result
        """
        import subprocess
        import os
        
        # Store start time
        start_time = get_timestamp()
        
        # Execute command
        self.console.print(f"\n[blue]$ {command}[/blue]")
        
        try:
            # Execute the command in a bash shell
            process = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                executable="/bin/bash" if os.name != "nt" else None
            )
            
            # Get output and status
            stdout = process.stdout.strip()
            stderr = process.stderr.strip()
            success = process.returncode == 0
            
            # Display output or error
            if success and stdout:
                self.console.print(Panel(stdout, title="Output", border_style="green"))
            if stderr:
                self.console.print(Panel(stderr, title="Error", border_style="red"))
            
            # If command failed but we have a fallback, try that
            if not success and fallback:
                self.console.print(f"[yellow]Command failed. Trying fallback command...[/yellow]")
                self.console.print(f"[blue]$ {fallback}[/blue]")
                
                fallback_process = subprocess.run(
                    fallback,
                    shell=True,
                    capture_output=True,
                    text=True,
                    executable="/bin/bash" if os.name != "nt" else None
                )
                
                fallback_stdout = fallback_process.stdout.strip()
                fallback_stderr = fallback_process.stderr.strip()
                fallback_success = fallback_process.returncode == 0
                
                if fallback_success and fallback_stdout:
                    self.console.print(Panel(fallback_stdout, title="Fallback Output", border_style="green"))
                if fallback_stderr:
                    self.console.print(Panel(fallback_stderr, title="Fallback Error", border_style="red"))
                
                # Use fallback results if main command failed
                if fallback_success:
                    stdout = fallback_stdout
                    stderr = fallback_stderr
                    success = True
            
            if not success:
                self.console.print("[bold red]Command execution failed.[/bold red]")
            
            # Return result
            return {
                "action": {
                    "type": "shell_command",
                    "content": command
                },
                "output": stdout,
                "error": stderr,
                "success": success,
                "start_time": start_time,
                "end_time": get_timestamp()
            }
            
        except Exception as e:
            # Handle execution error
            self.console.print(f"[bold red]Error executing command: {str(e)}[/bold red]")
            
            # Try fallback if available
            if fallback:
                self.console.print(f"[yellow]Command failed. Trying fallback command...[/yellow]")
                try:
                    return self._execute_shell_command(fallback)  # Use the same method for the fallback
                except Exception as fallback_e:
                    self.console.print(f"[bold red]Fallback command also failed: {str(fallback_e)}[/bold red]")
            
            # Return error result
            return {
                "action": {
                    "type": "shell_command",
                    "content": command
                },
                "output": "",
                "error": str(e),
                "success": False,
                "start_time": start_time,
                "end_time": get_timestamp()
            }

    def _execute_python_code(self, code: str) -> Dict[str, Any]:
        """
        Execute Python code in a temporary file and capture output.
        
        Args:
            code: Python code to execute
            
        Returns:
            Dictionary with execution results
        """
        start_time = time.time()
        
        try:
            # Create a temporary directory and file
            with tempfile.TemporaryDirectory() as temp_dir:
                script_path = Path(temp_dir) / "termora_script.py"
                
                # Write code to file
                with open(script_path, "w") as f:
                    f.write(code)
                
                # Execute the Python script
                process = subprocess.run(
                    [sys.executable, str(script_path)],
                    capture_output=True,
                    text=True
                )
                
                duration = time.time() - start_time
                
                # Format the output
                output = process.stdout
                error = process.stderr
                exit_code = process.returncode
                
                # Display outputs
                if output:
                    self.console.print(Panel(output, title="[green]Output[/green]", border_style="green"))
                if error:
                    self.console.print(Panel(error, title="[red]Error[/red]", border_style="red"))
                    
                # Create result
                result = {
                    "action": {"type": "python_code", "content": code},
                    "output": output,
                    "error": error,
                    "exit_code": exit_code,
                    "duration": duration,
                    "success": exit_code == 0
                }
                
                return result
                
        except Exception as e:
            duration = time.time() - start_time
            self.console.print(f"[red]Error executing Python code: {str(e)}[/red]")
            
            return {
                "action": {"type": "python_code", "content": code},
                "output": "",
                "error": str(e),
                "exit_code": 1,
                "duration": duration,
                "success": False
            }